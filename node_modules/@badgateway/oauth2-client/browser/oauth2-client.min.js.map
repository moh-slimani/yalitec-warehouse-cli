{"version":3,"file":"oauth2-client.min.js","mappings":"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","sources":["webpack://OAuth2Client/webpack/universalModuleDefinition","webpack://OAuth2Client/./src/client.ts","webpack://OAuth2Client/./src/client/authorization-code.ts","webpack://OAuth2Client/./src/error.ts","webpack://OAuth2Client/./src/fetch-wrapper.ts","webpack://OAuth2Client/webpack/bootstrap","webpack://OAuth2Client/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OAuth2Client\"] = factory();\n\telse\n\t\troot[\"OAuth2Client\"] = factory();\n})(self, () => {\nreturn ","import { OAuth2Token } from './token';\nimport {\n  AuthorizationCodeRequest,\n  ClientCredentialsRequest,\n  IntrospectionRequest,\n  IntrospectionResponse,\n  PasswordRequest,\n  RefreshRequest,\n  ServerMetadataResponse,\n  TokenResponse,\n} from './messages';\nimport { OAuth2Error } from './error';\nimport { OAuth2AuthorizationCodeClient } from './client/authorization-code';\n\nexport interface ClientSettings {\n\n  /**\n   * The hostname of the OAuth2 server.\n   * If provided, we'll attempt to discover all the other related endpoints.\n   *\n   * If this is not desired, just specify the other endpoints manually.\n   *\n   * This url will also be used as the base URL for all other urls. This lets\n   * you specify all the other urls as relative.\n   */\n  server?: string;\n\n  /**\n   * OAuth2 clientId\n   */\n  clientId: string;\n\n  /**\n   * OAuth2 clientSecret\n   *\n   * This is required when using the 'client_secret_basic' authenticationMethod\n   * for the client_credentials and password flows, but not authorization_code\n   * or implicit.\n   */\n  clientSecret?: string;\n\n  /**\n   * The /authorize endpoint.\n   *\n   * Required only for the browser-portion of the authorization_code flow.\n   */\n  authorizationEndpoint?: string;\n\n  /**\n   * The token endpoint.\n   *\n   * Required for most grant types and refreshing tokens.\n   */\n  tokenEndpoint?: string;\n\n  /**\n   * Introspection endpoint.\n   *\n   * Required for, well, introspecting tokens.\n   * If not provided we'll try to discover it, or otherwise default to /introspect\n   */\n  introspectionEndpoint?: string;\n\n  /**\n   * OAuth 2.0 Authorization Server Metadata endpoint or OpenID\n   * Connect Discovery 1.0 endpoint.\n   *\n   * If this endpoint is provided it can be used to automatically figure\n   * out all the other endpoints.\n   *\n   * Usually the URL for this is: https://server/.well-known/oauth-authorization-server\n   */\n  discoveryEndpoint?: string;\n\n  /**\n   * Fetch implementation to use.\n   *\n   * Set this if you wish to explicitly set the fetch implementation, e.g. to\n   * implement middlewares or set custom headers.\n   */\n  fetch?: typeof fetch;\n\n  /**\n   * Client authentication method that is used to authenticate\n   * when using the token endpoint.\n   *\n   * Can be one of 'client_secret_basic' | 'client_secret_post'.\n   *\n   * The default value is 'client_secret_basic' if not provided.\n   */\n  authenticationMethod?: string;\n}\n\n\ntype OAuth2Endpoint = 'tokenEndpoint' | 'authorizationEndpoint' | 'discoveryEndpoint' | 'introspectionEndpoint';\n\nexport class OAuth2Client {\n\n  settings: ClientSettings;\n\n  constructor(clientSettings: ClientSettings) {\n\n    if (!clientSettings?.fetch) {\n      clientSettings.fetch = fetch.bind(globalThis);\n    }\n    this.settings = clientSettings;\n\n  }\n\n  /**\n   * Refreshes an existing token, and returns a new one.\n   */\n  async refreshToken(token: OAuth2Token): Promise<OAuth2Token> {\n\n    if (!token.refreshToken) {\n      throw new Error('This token didn\\'t have a refreshToken. It\\'s not possible to refresh this');\n    }\n\n    const body: RefreshRequest = {\n      grant_type: 'refresh_token',\n      refresh_token: token.refreshToken,\n    };\n    if (!this.settings.clientSecret) {\n      // If there's no secret, send the clientId in the body.\n      body.client_id = this.settings.clientId;\n    }\n\n    return this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n\n  }\n\n  /**\n   * Retrieves an OAuth2 token using the client_credentials grant.\n   */\n  async clientCredentials(params?: { scope?: string[]; extraParams?: Record<string, string> }): Promise<OAuth2Token> {\n\n    const disallowed = ['client_id', 'client_secret', 'grant_type', 'scope'];\n\n    if (params?.extraParams && Object.keys(params.extraParams).filter((key) => disallowed.includes(key)).length > 0) {\n      throw new Error(`The following extraParams are disallowed: '${disallowed.join(\"', '\")}'`);\n    }\n\n    const body: ClientCredentialsRequest = {\n      grant_type: 'client_credentials',\n      scope: params?.scope?.join(' '),\n      ...params?.extraParams\n    };\n\n    if (!this.settings.clientSecret) {\n      throw new Error('A clientSecret must be provided to use client_credentials');\n    }\n\n    return this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n\n  }\n\n  /**\n   * Retrieves an OAuth2 token using the 'password' grant'.\n   */\n  async password(params: { username: string; password: string; scope?: string[] }): Promise<OAuth2Token> {\n\n    const body: PasswordRequest = {\n      grant_type: 'password',\n      ...params,\n      scope: params.scope?.join(' '),\n    };\n    return this.tokenResponseToOAuth2Token(this.request('tokenEndpoint', body));\n\n  }\n\n  /**\n   * Returns the helper object for the `authorization_code` grant.\n   */\n  get authorizationCode(): OAuth2AuthorizationCodeClient {\n\n    return new OAuth2AuthorizationCodeClient(\n      this,\n    );\n\n  }\n\n  /**\n   * Introspect a token\n   *\n   * This will give information about the validity, owner, which client\n   * created the token and more.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7662\n   */\n  async introspect(token: OAuth2Token): Promise<IntrospectionResponse> {\n\n    const body: IntrospectionRequest = {\n      token: token.accessToken,\n      token_type_hint: 'access_token',\n    };\n    return this.request('introspectionEndpoint', body);\n\n  }\n\n  /**\n   * Returns a url for an OAuth2 endpoint.\n   *\n   * Potentially fetches a discovery document to get it.\n   */\n  async getEndpoint(endpoint: OAuth2Endpoint): Promise<string> {\n\n    if (this.settings[endpoint] !== undefined) {\n      return resolve(this.settings[endpoint] as string, this.settings.server);\n    }\n\n    if (endpoint !== 'discoveryEndpoint') {\n      // This condition prevents infinite loops.\n      await this.discover();\n      if (this.settings[endpoint] !== undefined) {\n        return resolve(this.settings[endpoint] as string, this.settings.server);\n      }\n    }\n\n    // If we got here it means we need to 'guess' the endpoint.\n    if (!this.settings.server) {\n      throw new Error(`Could not determine the location of ${endpoint}. Either specify ${endpoint} in the settings, or the \"server\" endpoint to let the client discover it.`);\n    }\n\n    switch (endpoint) {\n      case 'authorizationEndpoint':\n        return resolve('/authorize', this.settings.server);\n      case 'tokenEndpoint':\n        return resolve('/token', this.settings.server);\n      case 'discoveryEndpoint':\n        return resolve('/.well-known/oauth-authorization-server', this.settings.server);\n      case 'introspectionEndpoint':\n        return resolve('/introspect', this.settings.server);\n    }\n\n  }\n\n  private discoveryDone = false;\n  private serverMetadata: ServerMetadataResponse | null = null;\n\n\n  /**\n   * Fetches the OAuth2 discovery document\n   */\n  private async discover(): Promise<void> {\n\n    // Never discover twice\n    if (this.discoveryDone) return;\n    this.discoveryDone = true;\n\n    let discoverUrl;\n    try {\n      discoverUrl = await this.getEndpoint('discoveryEndpoint');\n    } catch (err) {\n      console.warn('[oauth2] OAuth2 discovery endpoint could not be determined. Either specify the \"server\" or \"discoveryEndpoint');\n      return;\n    }\n    const resp = await this.settings.fetch!(discoverUrl, { headers: { Accept: 'application/json' }});\n\n    if (!resp.ok) return;\n    if (!resp.headers.get('Content-Type')?.startsWith('application/json')) {\n      console.warn('[oauth2] OAuth2 discovery endpoint was not a JSON response. Response is ignored');\n      return;\n    }\n    this.serverMetadata = await resp.json();\n\n    const urlMap = [\n      ['authorization_endpoint', 'authorizationEndpoint'],\n      ['token_endpoint', 'tokenEndpoint'],\n      ['introspection_endpoint', 'introspectionEndpoint'],\n    ] as const;\n\n    if (this.serverMetadata === null) return;\n\n    for (const [property, setting] of urlMap) {\n      if (!this.serverMetadata[property]) continue;\n      this.settings[setting] = resolve(this.serverMetadata[property]!, discoverUrl);\n    }\n\n    if (this.serverMetadata.token_endpoint_auth_methods_supported && !this.settings.authenticationMethod) {\n      this.settings.authenticationMethod = this.serverMetadata.token_endpoint_auth_methods_supported[0];\n    }\n\n  }\n\n  /**\n   * Does a HTTP request on the 'token' endpoint.\n   */\n  async request(endpoint: 'tokenEndpoint', body: RefreshRequest | ClientCredentialsRequest | PasswordRequest | AuthorizationCodeRequest): Promise<TokenResponse>;\n  async request(endpoint: 'introspectionEndpoint', body: IntrospectionRequest): Promise<IntrospectionResponse>;\n  async request(endpoint: OAuth2Endpoint, body: Record<string, any>): Promise<unknown> {\n\n    const uri = await this.getEndpoint(endpoint);\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    };\n\n    let authMethod = this.settings.authenticationMethod;\n    if (!authMethod) {\n      authMethod = this.settings.clientSecret ? 'client_secret_basic' : 'client_secret_post';\n    }\n\n    switch(authMethod) {\n      case 'client_secret_basic' :\n        headers.Authorization = 'Basic ' +\n          btoa(this.settings.clientId + ':' + this.settings.clientSecret);\n        break;\n      case 'client_secret_post' :\n        body.client_id = this.settings.clientId;\n        if (this.settings.clientSecret) {\n          body.client_secret = this.settings.clientSecret;\n        }\n        break;\n      default:\n        throw new Error('Authentication method not yet supported:' + authMethod + '. Open a feature request if you want this!');\n    }\n\n    const resp = await this.settings.fetch!(uri, {\n      method: 'POST',\n      body: generateQueryString(body),\n      headers,\n    });\n\n    if (resp.ok) {\n      return await resp.json();\n    }\n\n    let jsonError;\n    let errorMessage;\n    let oauth2Code;\n    if (resp.headers.has('Content-Type') && resp.headers.get('Content-Type')!.startsWith('application/json')) {\n      jsonError = await resp.json();\n    }\n\n    if (jsonError?.error) {\n      // This is likely an OAUth2-formatted error\n      errorMessage = 'OAuth2 error ' + jsonError.error + '.';\n      if (jsonError.error_description) {\n        errorMessage += ' ' + jsonError.error_description;\n      }\n      oauth2Code = jsonError.error;\n\n    } else {\n      errorMessage = 'HTTP Error ' + resp.status + ' ' + resp.statusText;\n      if (resp.status === 401 && this.settings.clientSecret) {\n        errorMessage += '. It\\'s likely that the clientId and/or clientSecret was incorrect';\n      }\n      oauth2Code = null;\n    }\n    throw new OAuth2Error(errorMessage, oauth2Code, resp.status);\n  }\n\n  /**\n   * Converts the JSON response body from the token endpoint to an OAuth2Token type.\n   */\n  tokenResponseToOAuth2Token(resp: Promise<TokenResponse>): Promise<OAuth2Token> {\n\n    return resp.then(body => ({\n      accessToken: body.access_token,\n      expiresAt: body.expires_in ? Date.now() + (body.expires_in * 1000) : null,\n      refreshToken: body.refresh_token ?? null,\n    }));\n\n  }\n\n}\n\nfunction resolve(uri: string, base?: string): string {\n\n  return new URL(uri, base).toString();\n\n}\n\n/**\n * Generates a query string.\n *\n * This function filters out any undefined values.\n */\nexport function generateQueryString(params: Record<string, undefined | number | string>): string {\n\n  return new URLSearchParams(\n    Object.fromEntries(\n      Object.entries(params).filter(([k, v]) => v !== undefined)\n    ) as Record<string, string>\n  ).toString();\n\n}\n","import { OAuth2Client, generateQueryString } from '../client';\nimport { OAuth2Token } from '../token';\nimport { AuthorizationCodeRequest, AuthorizationQueryParams } from '../messages';\nimport { OAuth2Error } from '../error';\n\ntype GetAuthorizeUrlParams = {\n  /**\n   * Where to redirect the user back to after authentication.\n   */\n  redirectUri: string;\n\n  /**\n   * The 'state' is a string that can be sent to the authentication server,\n   * and back to the redirectUri.\n   */\n  state?: string;\n\n  /**\n   * Code verifier for PKCE support. If you used this in the redirect\n   * to the authorization endpoint, you also need to use this again\n   * when getting the access_token on the token endpoint.\n   */\n  codeVerifier?: string;\n\n  /**\n   * List of scopes.\n   */\n  scope?: string[];\n\n  /**\n   * Any parameters listed here will be added to the query string for the authorization server endpoint.\n   */\n  extraParams?: Record<string, string>;\n}\n\ntype ValidateResponseResult = {\n\n  /**\n   * The authorization code. This code should be used to obtain an access token.\n   */\n  code: string;\n\n  /**\n   * List of scopes that the client requested.\n   */\n  scope?: string[];\n\n}\n\nexport class OAuth2AuthorizationCodeClient {\n\n  client: OAuth2Client;\n\n  constructor(client: OAuth2Client) {\n\n    this.client = client;\n\n  }\n\n  /**\n   * Returns the URi that the user should open in a browser to initiate the\n   * authorization_code flow.\n   */\n  async getAuthorizeUri(params: GetAuthorizeUrlParams): Promise<string> {\n\n    const [\n      codeChallenge,\n      authorizationEndpoint\n    ] = await Promise.all([\n      params.codeVerifier ? getCodeChallenge(params.codeVerifier) : undefined,\n      this.client.getEndpoint('authorizationEndpoint')\n    ]);\n\n    let query: AuthorizationQueryParams = {\n      client_id: this.client.settings.clientId,\n      response_type: 'code',\n      redirect_uri: params.redirectUri,\n      code_challenge_method: codeChallenge?.[0],\n      code_challenge: codeChallenge?.[1],\n    };\n    if (params.state) {\n      query.state = params.state;\n    }\n    if (params.scope) {\n      query.scope = params.scope.join(' ');\n    }\n\n    const disallowed = Object.keys(query);\n\n    if (params?.extraParams && Object.keys(params.extraParams).filter((key) => disallowed.includes(key)).length > 0) {\n      throw new Error(`The following extraParams are disallowed: '${disallowed.join(\"', '\")}'`);\n    }\n\n    query = {...query, ...params?.extraParams};\n\n\n    return authorizationEndpoint + '?' + generateQueryString(query);\n\n  }\n\n  async getTokenFromCodeRedirect(url: string|URL, params: {redirectUri: string; state?: string; codeVerifier?:string} ): Promise<OAuth2Token> {\n\n    const { code } = await this.validateResponse(url, {\n      state: params.state\n    });\n\n    return this.getToken({\n      code,\n      redirectUri: params.redirectUri,\n      codeVerifier: params.codeVerifier,\n    });\n\n  }\n\n  /**\n   * After the user redirected back from the authorization endpoint, the\n   * url will contain a 'code' and other information.\n   *\n   * This function takes the url and validate the response. If the user\n   * redirected back with an error, an error will be thrown.\n   */\n  async validateResponse(url: string|URL, params: {state?: string}): Promise<ValidateResponseResult> {\n\n    const queryParams = new URL(url).searchParams;\n\n    if (queryParams.has('error')) {\n      throw new OAuth2Error(\n        queryParams.get('error_description') ?? 'OAuth2 error',\n        queryParams.get('error')!,\n        0,\n      );\n    }\n\n    if (!queryParams.has('code')) throw new Error(`The url did not contain a code parameter ${url}`);\n\n    if (params.state && params.state !== queryParams.get('state')) {\n      throw new Error(`The \"state\" parameter in the url did not match the expected value of ${params.state}`);\n    }\n\n    return {\n      code: queryParams.get('code')!,\n      scope: queryParams.has('scope') ? queryParams.get('scope')!.split(' ') : undefined,\n    };\n\n  }\n\n\n  /**\n   * Receives an OAuth2 token using 'authorization_code' grant\n   */\n  async getToken(params: { code: string; redirectUri: string; codeVerifier?: string }): Promise<OAuth2Token> {\n\n    const body:AuthorizationCodeRequest = {\n      grant_type: 'authorization_code',\n      code: params.code,\n      redirect_uri: params.redirectUri,\n      code_verifier: params.codeVerifier,\n    };\n    return this.client.tokenResponseToOAuth2Token(this.client.request('tokenEndpoint', body));\n\n  }\n\n\n}\n\nexport async function generateCodeVerifier(): Promise<string> {\n\n  const webCrypto = getWebCrypto();\n  if (webCrypto) {\n    const arr = new Uint8Array(32);\n    webCrypto.getRandomValues(arr);\n    return base64Url(arr);\n  } else {\n\n    // Old node doesn't have 'webcrypto', so this is a fallback\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const nodeCrypto = require('crypto');\n    return new Promise<string>((res, rej) => {\n      nodeCrypto.randomBytes(32, (err:Error, buf: Buffer) => {\n        if (err) rej(err);\n        res(buf.toString('base64url'));\n      });\n    });\n\n  }\n\n}\n\nexport async function getCodeChallenge(codeVerifier: string): Promise<['plain' | 'S256', string]> {\n\n  const webCrypto = getWebCrypto();\n  if (webCrypto?.subtle) {\n    return ['S256', base64Url(await webCrypto.subtle.digest('SHA-256', stringToBuffer(codeVerifier)))];\n  } else {\n    // Node 14.x fallback\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const nodeCrypto = require('crypto');\n    const hash = nodeCrypto.createHash('sha256');\n    hash.update(stringToBuffer(codeVerifier));\n    return ['S256', hash.digest('base64url')];\n  }\n\n}\n\nfunction getWebCrypto() {\n\n  // Browsers\n  if ((typeof window !== 'undefined' && window.crypto)) {\n    return window.crypto;\n  }\n  // Web workers possibly\n  if ((typeof self !== 'undefined' && self.crypto)) {\n    return self.crypto;\n  }\n  // Node\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const crypto = require('crypto');\n  if (crypto.webcrypto) {\n    return crypto.webcrypto;\n  }\n  return null;\n\n}\n\nfunction stringToBuffer(input: string): ArrayBuffer {\n\n  const buf = new Uint8Array(input.length);\n  for(let i=0; i<input.length;i++) {\n    buf[i] = input.charCodeAt(i) & 0xFF;\n  }\n  return buf;\n\n}\n\nfunction base64Url(buf: ArrayBuffer) {\n  return (\n    btoa(String.fromCharCode(...new Uint8Array(buf)))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/, '')\n  );\n}\n\n","/**\n * An error class for any error the server emits.\n *\n * The 'code' property will have the oauth2 error type,\n * such as:\n * - invalid_request\n * - invalid_client\n * - invalid_grant\n * - unauthorized_client\n * - unsupported_grant_type\n * - invalid_scope\n */\nexport class OAuth2Error extends Error {\n\n  oauth2Code: string;\n  httpCode: number;\n\n  constructor(message: string, oauth2Code: string, httpCode: number) {\n\n    super(message);\n\n    this.oauth2Code = oauth2Code;\n    this.httpCode = httpCode;\n\n  }\n\n}\n","import { OAuth2Token } from './token';\nimport { OAuth2Client } from './client';\n\ntype FetchMiddleware = (request: Request, next: (request: Request) => Promise<Response>) => Promise<Response>;\n\ntype OAuth2FetchOptions = {\n\n  /**\n   * Reference to OAuth2 client.\n   */\n  client: OAuth2Client;\n\n  /**\n   * You are responsible for implementing this function.\n   * it's purpose is to supply the 'initial' oauth2 token.\n   *\n   * This function may be async. Return `null` to fail the process.\n   */\n  getNewToken(): OAuth2Token | null | Promise<OAuth2Token | null>;\n\n  /**\n   * If set, will be called if authentication fatally failed.\n   */\n  onError?: (err: Error) => void;\n\n  /**\n   * This function is called whenever the active token changes. Using this is\n   * optional, but it may be used to (for example) put the token in off-line\n   * storage for later usage.\n   */\n  storeToken?: (token: OAuth2Token) => void;\n\n  /**\n   * Also an optional feature. Implement this if you want the wrapper to try a\n   * stored token before attempting a full re-authentication.\n   *\n   * This function may be async. Return null if there was no token.\n   */\n  getStoredToken?: () => OAuth2Token | null | Promise<OAuth2Token | null>;\n\n  /**\n   * Whether to automatically schedule token refresh.\n   *\n   * Certain execution environments, e.g. React Native, do not handle scheduled\n   * tasks with setTimeout() in a graceful or predictable fashion. The default\n   * behavior is to schedule refresh. Set this to false to disable scheduling.\n   */\n  scheduleRefresh?: boolean;\n\n}\n\nexport class OAuth2Fetch {\n\n  private options: OAuth2FetchOptions;\n\n  /**\n   * Current active token (if any)\n   */\n  private token: OAuth2Token | null = null;\n\n  /**\n   * If the user had a storedToken, the process to fetch it\n   * may be async. We keep track of this process in this\n   * promise, so it may be awaited to avoid race conditions.\n   *\n   * As soon as this promise resolves, this property get nulled.\n   */\n  private activeGetStoredToken: null | Promise<void> = null;\n\n  constructor(options: OAuth2FetchOptions) {\n\n    if (options?.scheduleRefresh === undefined) {\n      options.scheduleRefresh = true;\n    }\n    this.options = options;\n    if (options.getStoredToken) {\n      this.activeGetStoredToken = (async () => {\n        this.token = await options.getStoredToken!();\n        this.activeGetStoredToken = null;\n      })();\n    }\n    this.scheduleRefresh();\n\n  }\n\n  /**\n   * Does a fetch request and adds a Bearer / access token.\n   *\n   * If the access token is not known, this function attempts to fetch it\n   * first. If the access token is almost expiring, this function might attempt\n   * to refresh it.\n   */\n  async fetch(input: RequestInfo, init?: RequestInit): Promise<Response> {\n\n    // input might be a string or a Request object, we want to make sure this\n    // is always a fully-formed Request object.\n    const request = new Request(input, init);\n\n    return this.mw()(\n      request,\n      req => fetch(req)\n    );\n\n  }\n\n  /**\n   * This function allows the fetch-mw to be called as more traditional\n   * middleware.\n   *\n   * This function returns a middleware function with the signature\n   *    (request, next): Response\n   */\n  mw(): FetchMiddleware {\n\n    return async (request, next) => {\n\n      const accessToken = await this.getAccessToken();\n\n      // Make a clone. We need to clone if we need to retry the request later.\n      let authenticatedRequest = request.clone();\n      authenticatedRequest.headers.set('Authorization', 'Bearer '  + accessToken);\n      let response = await next(authenticatedRequest);\n\n      if (!response.ok && response.status === 401) {\n\n        const newToken = await this.refreshToken();\n\n        authenticatedRequest = request.clone();\n        authenticatedRequest.headers.set('Authorization', 'Bearer '  + newToken.accessToken);\n        response = await next(authenticatedRequest);\n\n      }\n      return response;\n    };\n\n  }\n\n  /**\n   * Returns current token information.\n   *\n   * There result object will have:\n   *   * accessToken\n   *   * expiresAt - when the token expires, or null.\n   *   * refreshToken - may be null\n   *\n   * This function will attempt to automatically refresh if stale.\n   */\n  async getToken(): Promise<OAuth2Token> {\n\n    if (this.token && (this.token.expiresAt === null || this.token.expiresAt > Date.now())) {\n\n      // The current token is still valid\n      return this.token;\n\n    }\n\n    return this.refreshToken();\n\n  }\n\n  /**\n   * Returns an access token.\n   *\n   * If the current access token is not known, it will attempt to fetch it.\n   * If the access token is expiring, it will attempt to refresh it.\n   */\n  async getAccessToken(): Promise<string> {\n\n    // Ensure getStoredToken finished.\n    await this.activeGetStoredToken;\n\n    const token = await this.getToken();\n    return token.accessToken;\n\n  }\n\n  /**\n   * Keeping track of an active refreshToken operation.\n   *\n   * This will allow us to ensure only 1 such operation happens at any\n   * given time.\n   */\n  private activeRefresh: Promise<OAuth2Token> | null = null;\n\n  /**\n   * Forces an access token refresh\n   */\n  async refreshToken(): Promise<OAuth2Token> {\n\n    if (this.activeRefresh) {\n      // If we are currently already doing this operation,\n      // make sure we don't do it twice in parallel.\n      return this.activeRefresh;\n    }\n\n    const oldToken = this.token;\n    this.activeRefresh = (async() => {\n\n      let newToken: OAuth2Token|null = null;\n\n      try {\n        if (oldToken?.refreshToken) {\n          // We had a refresh token, lets see if we can use it!\n          newToken = await this.options.client.refreshToken(oldToken);\n        }\n      } catch (err) {\n        console.warn('[oauth2] refresh token not accepted, we\\'ll try reauthenticating');\n      }\n\n      if (!newToken) {\n        newToken = await this.options.getNewToken();\n      }\n\n      if (!newToken) {\n        const err = new Error('Unable to obtain OAuth2 tokens, a full reauth may be needed');\n        this.options.onError?.(err);\n        throw err;\n      }\n      return newToken;\n\n    })();\n\n    try {\n      const token = await this.activeRefresh;\n      this.token = token;\n      this.options.storeToken?.(token);\n      this.scheduleRefresh();\n      return token;\n    } catch (err: any) {\n      if (this.options.onError) {\n        this.options.onError(err);\n      }\n      throw err;\n    } finally {\n      // Make sure we clear the current refresh operation.\n      this.activeRefresh = null;\n    }\n\n  }\n\n  /**\n   * Timer trigger for the next automated refresh\n   */\n  private refreshTimer: ReturnType<typeof setTimeout> | null = null;\n\n  private scheduleRefresh() {\n    if (!this.options.scheduleRefresh) {\n      return;\n    }\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n\n    if (!this.token?.expiresAt || !this.token.refreshToken) {\n      // If we don't know when the token expires, or don't have a refresh_token, don't bother.\n      return;\n    }\n\n    const expiresIn = this.token.expiresAt - Date.now();\n\n    // We only schedule this event if it happens more than 2 minutes in the future.\n    if (expiresIn < 120*1000) {\n      return;\n    }\n\n    // Schedule 1 minute before expiry\n    this.refreshTimer = setTimeout(async () => {\n      try {\n        await this.refreshToken();\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.error('[fetch-mw-oauth2] error while doing a background OAuth2 auto-refresh', err);\n      }\n    }, expiresIn - 60*1000);\n\n  }\n\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { OAuth2Client } from './client';\nexport { OAuth2AuthorizationCodeClient, generateCodeVerifier } from './client/authorization-code';\nexport { OAuth2Fetch } from './fetch-wrapper';\nexport { OAuth2Token } from './token';\nexport { OAuth2Error } from './error';\n\nexport { IntrospectionResponse } from './messages';\n"],"names":["root","factory","exports","module","define","amd","self","resolve","uri","base","URL","toString","generateQueryString","params","URLSearchParams","Object","fromEntries","entries","filter","k","v","undefined","constructor","clientSettings","discoveryDone","serverMetadata","fetch","bind","globalThis","this","settings","refreshToken","token","Error","body","grant_type","refresh_token","clientSecret","client_id","clientId","tokenResponseToOAuth2Token","request","clientCredentials","disallowed","extraParams","keys","key","includes","length","join","scope","password","authorizationCode","OAuth2AuthorizationCodeClient","introspect","accessToken","token_type_hint","getEndpoint","endpoint","server","discover","discoverUrl","err","console","warn","resp","headers","Accept","ok","get","startsWith","json","urlMap","property","setting","token_endpoint_auth_methods_supported","authenticationMethod","authMethod","Authorization","btoa","client_secret","method","jsonError","errorMessage","oauth2Code","has","error","error_description","status","statusText","OAuth2Error","then","access_token","expiresAt","expires_in","Date","now","async","getCodeChallenge","codeVerifier","webCrypto","getWebCrypto","subtle","base64Url","digest","stringToBuffer","hash","createHash","update","window","crypto","webcrypto","input","buf","Uint8Array","i","charCodeAt","String","fromCharCode","replace","client","getAuthorizeUri","codeChallenge","authorizationEndpoint","Promise","all","query","response_type","redirect_uri","redirectUri","code_challenge_method","code_challenge","state","getTokenFromCodeRedirect","url","code","validateResponse","getToken","queryParams","searchParams","split","code_verifier","arr","getRandomValues","nodeCrypto","res","rej","randomBytes","message","httpCode","super","options","activeGetStoredToken","activeRefresh","refreshTimer","scheduleRefresh","getStoredToken","init","Request","mw","req","next","getAccessToken","authenticatedRequest","clone","set","response","newToken","oldToken","getNewToken","onError","storeToken","clearTimeout","expiresIn","setTimeout","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","OAuth2Client","generateCodeVerifier","OAuth2Fetch"],"sourceRoot":""}