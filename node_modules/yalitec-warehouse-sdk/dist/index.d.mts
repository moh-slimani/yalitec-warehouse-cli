import { OAuth2Token } from '@badgateway/oauth2-client';
import { ClientSettings } from '@badgateway/oauth2-client/dist/client';

interface Response<T> {
    data: T;
    links?: Links;
    meta?: Meta;
}
interface Links {
    first: string;
    last: string;
    prev: any;
    next: string;
}
interface Meta {
    current_page: number;
    from: number;
    last_page: number;
    links: Link[];
    path: string;
    per_page: number;
    to: number;
    total: number;
}
interface Link {
    url?: string;
    label: string;
    active: boolean;
}

interface FetchOptions {
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    body?: any;
}
interface ClientPasswordParams {
    username: string;
    password: string;
    scope?: string[];
}
interface Endpoints {
    [key: string]: {
        index: string;
        create: string;
        show(id: (number | string)): string;
        update(id: (number | string)): string;
        delete(id: (number | string)): string;
    };
}

interface Warehouse {
    id: number;
    name: string;
    description?: string;
}

interface Store {
    id: number;
    seller_id: string;
    name: string;
    phone: string;
    description?: string;
    state_id?: number;
    city_id?: number;
    created_at: string;
    updated_at: string;
}
interface StoreCreateInput {
    seller_id: string;
    name: string;
    phone: string;
    description?: string;
    state_id?: number;
    city_id?: number;
}
interface StoreUpdateInput {
    seller_id?: string;
    name?: string;
    phone?: string;
    description?: string;
    state_id?: number;
    city_id?: number;
}

interface Outbound {
    store_id: number;
    number: string;
    type: string;
    status: string;
    note?: string;
    invoice_n: string;
    name: string;
    address: string;
    address2?: string;
    zip?: string;
    phone: string;
    freeshipping: boolean;
    is_stopdesk: boolean;
    has_exchange: boolean;
    product_to_collect: any;
    city_id: number;
    state_id: number;
    warehouse_id: number;
    outboundProducts: OutboundProduct[];
    created_at: string;
    updated_at: string;
    validated_at: string;
    packaged_at: string;
    shipping_id: string;
    shipping_status: string;
    isStockReady: boolean;
    productCodes: string[];
}
interface OutboundsFilter {
    page?: number;
    sellerId?: string;
    sellerIds?: string[];
    sku?: string;
    skus?: string[];
    storeId?: number;
    storeIds?: number[];
    status?: string;
}
interface OutboundProduct {
    id: number;
    status?: string;
    quantity: number;
    price: number;
    created_at: string;
    updated_at?: string;
    deleted_at?: string;
    returned_damaged?: string;
    returned_undamaged?: string;
    sku: string;
    name: string;
}
interface OutboundProductsInput {
    sku: string;
    quantity: number;
    price: number;
}
interface OutboundCreateInput {
    warehouse_id: number;
    store_id: number;
    invoice_n: string;
    shipping_id: string;
    shipping_status: string;
    name: string;
    phone: string;
    note?: string;
    address: string;
    address2?: string;
    state_id: string;
    city_id: string;
    zip?: string;
    price: number;
    freeshipping: boolean;
    is_stopdesk: boolean;
    has_exchange: boolean;
    product_to_collect?: string;
    outboundProducts: {
        create: OutboundProductsInput[];
    };
}
interface OutboundUpdateInput {
    warehouse_id: number;
    store_id: number;
    invoice_n: string;
    shipping_id: string;
    shipping_status: string;
    name: string;
    phone: string;
    note?: string;
    address: string;
    address2?: string;
    state_id: string;
    city_id: string;
    zip?: string;
    price: number;
    freeshipping: boolean;
    is_stopdesk: boolean;
    has_exchange: boolean;
    product_to_collect?: string;
    outboundProducts?: {
        create?: OutboundProductsInput[];
        update?: OutboundProductsInput[];
        delete?: string[];
    };
}

interface Product {
    store_id: number;
    name: string;
    sku: string;
    category: string;
    size: "small" | "medium" | "large" | "huge";
    width?: number;
    height?: number;
    length?: number;
    weight?: number;
    description?: string;
    value: number;
    variant?: string;
    variant_of?: number;
    total: number;
    incoming: number;
    incoming_return: number;
    in_warehouse: number;
    in_shelf: number;
    ready: number;
    delivered: number;
    on_process: number;
    damaged: number;
    created_at: string;
    updated_at: string;
    variants: Product[];
}
interface ProductsFilter {
    page?: number;
    sellerId?: string;
    sellerIds?: string[];
    sku?: string;
    skus?: string[];
    storeId?: number;
    storeIds?: number[];
}
interface ProductsVariantCreateInput {
    sku: string;
    value: number;
    variant: string;
}
interface ProductsVariantUpdateInput {
    sku: string;
    value: number;
    variant: string;
}
interface ProductCreateInput {
    store_id: number;
    name: string;
    sku: string;
    category: string;
    size: "small" | "medium" | "large" | "huge";
    description?: string;
    value: number;
    variant?: string;
    variant_of?: string;
    variants?: {
        create: ProductsVariantCreateInput[];
    };
}
interface ProductUpdateInput {
    store_id: number;
    name: string;
    category: string;
    size: "small" | "medium" | "large" | "huge";
    description?: string;
    value: number;
    variant?: string;
    variant_of?: string;
    variants?: {
        create?: ProductsVariantCreateInput[];
        update?: ProductsVariantUpdateInput[];
    };
}

interface Inbound {
    store_id: number;
    number: string;
    type: "Walk In" | "Pick Up";
    status: string;
    inbound_date: string;
    phone: string;
    note: any;
    address: any;
    address2: any;
    zip: any;
    city_id: any;
    state_id: any;
    warehouse_id: number;
    inboundProducts: InboundProduct[];
    created_at: string;
    updated_at: string;
}
interface InboundsFilter {
    page?: number;
    sellerId?: string;
    sellerIds?: string[];
    storeId?: number;
    storeIds?: number[];
}
interface InboundProduct {
    id: number;
    name: string;
    quantity: number;
    quantity_received: number;
    expired_at: any;
    created_at: string;
    updated_at: string;
    quantity_damaged: any;
    variation: any;
    deleted_at: any;
    sku: string;
}
interface InboundCreateInputWalkIn {
    warehouse_id: number;
    store_id: number;
    type: "Walk In";
    phone: string;
    note?: string;
    inboundProducts: {
        create: InboundProductsCreateInput[];
    };
}
interface InboundCreateInputPickUp {
    warehouse_id: number;
    store_id: number;
    type: "Pick Up";
    phone: string;
    note?: string;
    address: string;
    address2?: string;
    zip?: string;
    city_id: string;
    state_id: string;
    inboundProducts: {
        create: InboundProductsCreateInput[];
    };
}
interface InboundProductsCreateInput {
    sku: string;
    quantity: number;
    variation?: string;
    expired_at?: string;
}
type InboundCreateInput = InboundCreateInputWalkIn | InboundCreateInputPickUp;
interface InboundUpdateInputWalkIn {
    warehouse_id: number;
    store_id: number;
    type: "Walk In";
    phone: string;
    note?: string;
    inboundProducts?: {
        create?: InboundProductsUpdateInput[];
        update?: InboundProductsUpdateInput[];
    };
}
interface InboundUpdateInputPickUp {
    warehouse_id: number;
    store_id: number;
    type: "Pick Up";
    phone: string;
    note?: string;
    address: string;
    address2?: string;
    zip?: string;
    city_id: string;
    state_id: string;
    inboundProducts?: {
        create?: InboundProductsCreateInput[];
        update?: InboundProductsUpdateInput[];
    };
}
interface InboundProductsUpdateInput {
    sku: string;
    quantity: number;
    variation?: string;
    expired_at?: string;
}
type InboundUpdateInput = InboundUpdateInputWalkIn | InboundUpdateInputPickUp;

declare class DataSource {
    protected readonly fetch: <T>(endpoint: string, options?: FetchOptions) => Promise<Response<T>>;
    protected readonly endpoints: Endpoints;
    constructor(fetch: <T>(endpoint: string, options?: FetchOptions) => Promise<Response<T>>, endpoints: Endpoints);
}

declare class WarehouseDataSource extends DataSource {
    list(): Promise<Response<Warehouse[]>>;
}

declare class StoreDataSource extends DataSource {
    list(seller_id?: string, page?: number): Promise<Response<Store[]>>;
    find(id: number): Promise<Response<Store>>;
    create(input: StoreCreateInput): Promise<Response<Store>>;
    update(id: number, input: StoreUpdateInput): Promise<Response<Store>>;
}

declare class ProductDataSource extends DataSource {
    list(options: ProductsFilter): Promise<Response<Product[]>>;
    find(sku: string): Promise<Response<Product>>;
    create(input: ProductCreateInput): Promise<Response<Product>>;
    update(sku: string, input: ProductUpdateInput): Promise<Response<Product>>;
}

declare class InboundDataSource extends DataSource {
    list(options: InboundsFilter): Promise<Response<Inbound[]>>;
    find(number: string): Promise<Response<Inbound>>;
    create(input: InboundCreateInput): Promise<Response<Inbound>>;
    update(number: string, input: InboundUpdateInput): Promise<Response<Inbound>>;
    delete(number: string): Promise<Response<Inbound>>;
}

declare class OutboundDataSource extends DataSource {
    list(options: OutboundsFilter): Promise<Response<Outbound[]>>;
    find(number: string): Promise<Response<Outbound>>;
    create(input: OutboundCreateInput): Promise<Response<Outbound>>;
    update(number: string, input: OutboundUpdateInput): Promise<Response<Outbound>>;
    delete(number: string): Promise<Response<Outbound>>;
}

declare const useFetch: (config: {
    clientSettings: ClientSettings;
    clientPasswordParams: ClientPasswordParams;
    storeTokenCallback: (token: OAuth2Token) => void;
    getStoredTokenCallback: () => OAuth2Token | null;
    loader?: {
        start: () => void;
        stop: () => void;
    } | undefined;
}) => {
    fetch: <T>(endpoint: string, options?: FetchOptions) => Promise<Response<T>>;
    scheduleRefresh: (token: OAuth2Token) => void;
};

declare const useConfig: (config: {
    server?: string;
    clientId?: string;
    clientSecret: string;
    tokenEndpoint?: string;
    username: string;
    password: string;
}) => {
    clientSettings: ClientSettings;
    clientPasswordParams: ClientPasswordParams;
    endpoints: Endpoints;
};

export { InboundDataSource, OutboundDataSource, ProductDataSource, StoreDataSource, WarehouseDataSource, useConfig, useFetch };
