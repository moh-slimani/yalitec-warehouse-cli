"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  InboundDataSource: () => InboundDataSource,
  OutboundDataSource: () => OutboundDataSource,
  ProductDataSource: () => ProductDataSource,
  StoreDataSource: () => StoreDataSource,
  WarehouseDataSource: () => WarehouseDataSource,
  useConfig: () => useConfig,
  useFetch: () => useFetch
});
module.exports = __toCommonJS(src_exports);

// src/dataSources/DataSource.ts
var DataSource = class {
  constructor(fetch, endpoints) {
    this.fetch = fetch;
    this.endpoints = endpoints;
  }
};

// src/dataSources/WarehouseDataSource.ts
var WarehouseDataSource = class extends DataSource {
  list() {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.warehouses.index);
    });
  }
};

// src/dataSources/StoreDataSource.ts
var StoreDataSource = class extends DataSource {
  list(seller_id, page) {
    return __async(this, null, function* () {
      let endpoint = this.endpoints.stores.index;
      let urlSearchParams = new URLSearchParams();
      if (seller_id) {
        urlSearchParams.append("seller_id", seller_id);
      }
      if (page) {
        urlSearchParams.append("page", page.toString());
      }
      if (urlSearchParams.size) {
        endpoint += "?" + urlSearchParams;
      }
      return yield this.fetch(endpoint);
    });
  }
  find(id) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.stores.show(id));
    });
  }
  create(input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.stores.create, {
        method: "POST",
        body: JSON.stringify(input)
      });
    });
  }
  update(id, input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.stores.update(id), {
        method: "PUT",
        body: JSON.stringify(input)
      });
    });
  }
};

// src/dataSources/ProductDataSource.ts
var ProductDataSource = class extends DataSource {
  list(options) {
    return __async(this, null, function* () {
      const {
        page,
        sellerId,
        sellerIds,
        sku,
        skus,
        storeId,
        storeIds
      } = options;
      let endpoint = this.endpoints.products.index;
      let urlSearchParams = new URLSearchParams();
      if (sku) {
        urlSearchParams.append("sku", sku);
      }
      if (skus) {
        skus.forEach((sku2) => urlSearchParams.append("skus[]", sku2));
      }
      if (storeId) {
        urlSearchParams.append("store_id", storeId.toString());
      }
      if (storeIds) {
        storeIds.forEach((storeId2) => urlSearchParams.append("store_ids[]", storeId2.toString()));
      }
      if (sellerId) {
        urlSearchParams.append("seller_id", sellerId);
      }
      if (sellerIds) {
        sellerIds.forEach((sellerId2) => urlSearchParams.append("seller_ids[]", sellerId2));
      }
      if (page) {
        urlSearchParams.append("page", page.toString());
      }
      if (urlSearchParams.size) {
        endpoint += "?" + urlSearchParams;
      }
      return yield this.fetch(endpoint);
    });
  }
  find(sku) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.products.show(sku));
    });
  }
  create(input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.products.create, {
        method: "POST",
        body: JSON.stringify(input)
      });
    });
  }
  update(sku, input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.products.update(sku), {
        method: "PUT",
        body: JSON.stringify(input)
      });
    });
  }
};

// src/dataSources/InboundDataSource.ts
var InboundDataSource = class extends DataSource {
  list(options) {
    return __async(this, null, function* () {
      const {
        page,
        sellerId,
        sellerIds,
        storeId,
        storeIds
      } = options;
      let endpoint = this.endpoints.inbounds.index;
      let urlSearchParams = new URLSearchParams();
      if (storeId) {
        urlSearchParams.append("store_id", storeId.toString());
      }
      if (storeIds) {
        storeIds.forEach((storeId2) => urlSearchParams.append("store_ids[]", storeId2.toString()));
      }
      if (sellerId) {
        urlSearchParams.append("seller_id", sellerId);
      }
      if (sellerIds) {
        sellerIds.forEach((sellerId2) => urlSearchParams.append("seller_ids[]", sellerId2));
      }
      if (page) {
        urlSearchParams.append("page", page.toString());
      }
      if (urlSearchParams.size) {
        endpoint += "?" + urlSearchParams;
      }
      return yield this.fetch(endpoint);
    });
  }
  find(number) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.inbounds.show(number));
    });
  }
  create(input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.inbounds.create, {
        method: "POST",
        body: JSON.stringify(input)
      });
    });
  }
  update(number, input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.inbounds.update(number), {
        method: "PUT",
        body: JSON.stringify(input)
      });
    });
  }
  delete(number) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.inbounds.delete(number), {
        method: "DELETE"
      });
    });
  }
};

// src/dataSources/OutboundDataSource.ts
var OutboundDataSource = class extends DataSource {
  list(options) {
    return __async(this, null, function* () {
      const {
        page,
        sellerId,
        sellerIds,
        storeId,
        storeIds,
        status,
        sku,
        skus
      } = options;
      let endpoint = this.endpoints.outbounds.index;
      let urlSearchParams = new URLSearchParams();
      if (storeId) {
        urlSearchParams.append("store_id", storeId.toString());
      }
      if (storeIds) {
        storeIds.forEach((storeId2) => urlSearchParams.append("store_ids[]", storeId2.toString()));
      }
      if (sellerId) {
        urlSearchParams.append("seller_id", sellerId);
      }
      if (sellerIds) {
        sellerIds.forEach((sellerId2) => urlSearchParams.append("seller_ids[]", sellerId2));
      }
      if (status) {
        urlSearchParams.append("status", status);
      }
      if (sku) {
        urlSearchParams.append("sku", sku);
      }
      if (skus) {
        skus.forEach((sku2) => urlSearchParams.append("skus[]", sku2));
      }
      if (page) {
        urlSearchParams.append("page", page.toString());
      }
      if (urlSearchParams.size) {
        endpoint += "?" + urlSearchParams;
      }
      return yield this.fetch(endpoint);
    });
  }
  find(number) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.outbounds.show(number));
    });
  }
  create(input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.outbounds.create, {
        method: "POST",
        body: JSON.stringify(input)
      });
    });
  }
  update(number, input) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.outbounds.update(number), {
        method: "PUT",
        body: JSON.stringify(input)
      });
    });
  }
  delete(number) {
    return __async(this, null, function* () {
      return yield this.fetch(this.endpoints.outbounds.delete(number), {
        method: "DELETE"
      });
    });
  }
};

// src/auth/index.ts
var import_oauth2_client = require("@badgateway/oauth2-client");
var refreshTimer = null;
var MAX_INT32 = 2147483647;
var useFetch = (config) => {
  const {
    clientSettings,
    clientPasswordParams,
    storeTokenCallback,
    getStoredTokenCallback,
    loader
  } = config;
  const client = new import_oauth2_client.OAuth2Client(clientSettings);
  const fetchWrapper = new import_oauth2_client.OAuth2Fetch({
    client,
    scheduleRefresh: false,
    getNewToken: () => __async(void 0, null, function* () {
      return client.password(clientPasswordParams);
    }),
    onError: (err) => {
      console.log("error : ", err.message);
    },
    storeToken: (token) => {
      storeTokenCallback(token);
    },
    getStoredToken: () => {
      return getStoredTokenCallback();
    }
  });
  const scheduleRefresh = (token) => {
    if (refreshTimer) {
      clearTimeout(refreshTimer);
      refreshTimer = null;
    }
    if (!(token == null ? void 0 : token.expiresAt) || !token.refreshToken) {
      return;
    }
    const expiresIn = token.expiresAt - Date.now();
    if (expiresIn < 120 * 1e3) {
      return;
    }
    const ms = Math.min(expiresIn - 60 * 1e3, MAX_INT32 - 1);
    refreshTimer = setTimeout(() => __async(void 0, null, function* () {
      try {
        fetchWrapper.refreshToken().then();
      } catch (err) {
        console.error("[fetch-mw-oauth2] error while doing a background OAuth2 auto-refresh", err);
      }
    }), ms);
  };
  const fetch = (endpoint, options) => __async(void 0, null, function* () {
    loader == null ? void 0 : loader.start();
    const response = yield fetchWrapper.fetch(endpoint, __spreadProps(__spreadValues({}, options), {
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      redirect: "follow"
    }));
    loader == null ? void 0 : loader.stop();
    if (!response.ok) {
      let message = yield response.text();
      throw new Error(message);
    } else {
      return yield response.json();
    }
  });
  return {
    fetch,
    scheduleRefresh
  };
};

// src/config/endpoints.ts
var getEndpoints = (server) => {
  return {
    warehouses: {
      index: `${server}/api/warehouses`,
      create: `${server}/api/warehouses`,
      show: (id) => `${server}/api/warehouses/${id}`,
      update: (id) => `${server}/api/warehouses/${id}`,
      delete: (id) => `${server}/api/warehouses/${id}`
    },
    stores: {
      index: `${server}/api/stores`,
      create: `${server}/api/stores`,
      show: (id) => `${server}/api/stores/${id}`,
      update: (id) => `${server}/api/stores/${id}`,
      delete: (id) => `${server}/api/stores/${id}`
    },
    products: {
      index: `${server}/api/products`,
      create: `${server}/api/products`,
      show: (sku) => `${server}/api/products/${sku}`,
      update: (sku) => `${server}/api/products/${sku}`,
      delete: (sku) => `${server}/api/products/${sku}`
    },
    inbounds: {
      index: `${server}/api/inbounds`,
      create: `${server}/api/inbounds`,
      show: (number) => `${server}/api/inbounds/${number}`,
      update: (number) => `${server}/api/inbounds/${number}`,
      delete: (number) => `${server}/api/inbounds/${number}`
    },
    outbounds: {
      index: `${server}/api/outbounds`,
      create: `${server}/api/outbounds`,
      show: (number) => `${server}/api/outbounds/${number}`,
      update: (number) => `${server}/api/outbounds/${number}`,
      delete: (number) => `${server}/api/outbounds/${number}`
    }
  };
};

// src/config/index.ts
var useConfig = (config) => {
  const {
    server = "https://beta-api.slimani.dev",
    clientId = "2",
    clientSecret,
    tokenEndpoint = "/oauth/token",
    password = "admin",
    username = "password"
  } = config;
  const clientSettings = {
    server,
    clientId,
    clientSecret,
    tokenEndpoint
  };
  const clientPasswordParams = {
    username,
    password
  };
  const endpoints = getEndpoints(server);
  return { clientSettings, clientPasswordParams, endpoints };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InboundDataSource,
  OutboundDataSource,
  ProductDataSource,
  StoreDataSource,
  WarehouseDataSource,
  useConfig,
  useFetch
});
//# sourceMappingURL=index.js.map